use core::cmp;
use std::{
	ffi::{CStr, CString, OsStr},
	io::{self, Error, ErrorKind},
	os::{fd::IntoRawFd, unix::ffi::OsStrExt},
};

use uhyve_interface::{
	GuestPhysAddr,
	v1::{self, MAX_ARGC_ENVC},
	v2::{self, parameters::*},
};

use crate::{
	isolation::{
		fd::{FdData, GuestFd},
		filemap::UhyveFileMap,
	},
	mem::{MemoryError, MmapMemory},
	params::EnvVars,
	virt_to_phys,
	vm::VmPeripherals,
};

/// `addr` is the address of the hypercall parameter in the guest's memory space. `data` is the
/// parameter that was send to that address by the guest.
///
/// # Safety
///
/// - The return value is only valid, as long as the guest is halted.
/// - This fn must not be called multiple times on the same data, to avoid creating mutable aliasing.
pub unsafe fn address_to_hypercall_v1(
	mem: &MmapMemory,
	addr: u16,
	data: GuestPhysAddr,
) -> Option<v1::Hypercall<'_>> {
	use v1::{Hypercall, HypercallAddress, parameters::*};
	if let Ok(hypercall_port) = HypercallAddress::try_from(addr) {
		Some(match hypercall_port {
			HypercallAddress::FileClose => {
				let sysclose = unsafe { mem.get_ref_mut::<CloseParams>(data).unwrap() };
				// let sysclose = unsafe { &mut *(self.host_address(data) as *mut CloseParams) };
				Hypercall::FileClose(sysclose)
			}
			HypercallAddress::FileLseek => {
				let syslseek = unsafe { mem.get_ref_mut::<LseekParams>(data).unwrap() };
				Hypercall::FileLseek(syslseek)
			}
			HypercallAddress::FileOpen => {
				let sysopen = unsafe { mem.get_ref_mut::<OpenParams>(data).unwrap() };
				Hypercall::FileOpen(sysopen)
			}
			HypercallAddress::FileRead => {
				let sysread = unsafe { mem.get_ref_mut::<ReadParams>(data).unwrap() };
				Hypercall::FileRead(sysread)
			}
			HypercallAddress::FileWrite => {
				let syswrite = unsafe { mem.get_ref_mut::<WriteParams>(data).unwrap() };
				Hypercall::FileWrite(syswrite)
			}
			HypercallAddress::FileUnlink => {
				let sysunlink = unsafe { mem.get_ref_mut::<UnlinkParams>(data).unwrap() };
				Hypercall::FileUnlink(sysunlink)
			}
			HypercallAddress::Exit => {
				let sysexit = unsafe { mem.get_ref_mut::<ExitParams>(data).unwrap() };
				Hypercall::Exit(sysexit)
			}
			HypercallAddress::Cmdsize => {
				let syssize = unsafe { mem.get_ref_mut::<CmdsizeParams>(data).unwrap() };
				Hypercall::Cmdsize(syssize)
			}
			HypercallAddress::Cmdval => {
				let syscmdval = unsafe { mem.get_ref_mut::<CmdvalParams>(data).unwrap() };
				Hypercall::Cmdval(syscmdval)
			}
			HypercallAddress::Uart => Hypercall::SerialWriteByte(data.as_u64() as u8),
			HypercallAddress::SerialBufferWrite => {
				let sysserialwrite =
					unsafe { mem.get_ref_mut::<SerialWriteBufferParams>(data).unwrap() };
				Hypercall::SerialWriteBuffer(sysserialwrite)
			}
			_ => return None,
		})
	} else {
		None
	}
}

/// `addr` is the address of the hypercall parameter in the guest's memory space. `data` is the
/// parameter that was send to that address by the guest.
///
/// # Safety
///
/// - The return value is only valid, as long as the guest is halted.
/// - This fn must not be called multiple times on the same data, to avoid creating mutable aliasing.
pub unsafe fn address_to_hypercall_v2(
	mem: &MmapMemory,
	addr: u16,
	data: GuestPhysAddr,
) -> Option<v2::Hypercall<'_>> {
	use v2::{Hypercall, HypercallAddress};
	if let Ok(hypercall_port) = HypercallAddress::try_from(addr as u64) {
		Some(match hypercall_port {
			HypercallAddress::FileClose => {
				let sysclose = unsafe { mem.get_ref_mut::<CloseParams>(data).unwrap() };
				// let sysclose = unsafe { &mut *(self.host_address(data) as *mut CloseParams) };
				Hypercall::FileClose(sysclose)
			}
			HypercallAddress::FileLseek => {
				let syslseek = unsafe { mem.get_ref_mut::<LseekParams>(data).unwrap() };
				Hypercall::FileLseek(syslseek)
			}
			HypercallAddress::FileOpen => {
				let sysopen = unsafe { mem.get_ref_mut::<OpenParams>(data).unwrap() };
				Hypercall::FileOpen(sysopen)
			}
			HypercallAddress::FileRead => {
				let sysread = unsafe { mem.get_ref_mut::<ReadParams>(data).unwrap() };
				Hypercall::FileRead(sysread)
			}
			HypercallAddress::FileWrite => {
				let syswrite = unsafe { mem.get_ref_mut::<WriteParams>(data).unwrap() };
				Hypercall::FileWrite(syswrite)
			}
			HypercallAddress::FileUnlink => {
				let sysunlink = unsafe { mem.get_ref_mut::<UnlinkParams>(data).unwrap() };
				Hypercall::FileUnlink(sysunlink)
			}
			HypercallAddress::Exit => Hypercall::Exit(data.as_u64() as i32),
			HypercallAddress::SerialReadBuffer => {
				let serialreadbuffer =
					unsafe { mem.get_ref_mut::<SerialReadBufferParams>(data).unwrap() };
				Hypercall::SerialReadBuffer(serialreadbuffer)
			}
			HypercallAddress::SerialWriteBuffer => {
				let serialwritebuffer =
					unsafe { mem.get_ref_mut::<SerialWriteBufferParams>(data).unwrap() };
				Hypercall::SerialWriteBuffer(serialwritebuffer)
			}
			HypercallAddress::SerialWriteByte => {
				let serialwritebyte =
					unsafe { mem.get_ref_mut::<SerialWriteBufferParams>(data).unwrap() };
				Hypercall::SerialWriteBuffer(serialwritebyte)
			}
			_ => return None,
		})
	} else {
		None
	}
}

/// unlink deletes a name from the filesystem. This is used to handle `unlink` syscalls from the guest.
///
/// Note for when using Landlock: Unlinking files results in them being veiled. If a text
/// file (that existed during initialization) called `log.txt` is unlinked, attempting to
/// open `log.txt` again will result in an error.
pub fn unlink(mem: &MmapMemory, sysunlink: &mut UnlinkParams, file_map: &mut UhyveFileMap) {
	let requested_path_ptr = mem.host_address(sysunlink.name).unwrap() as *const i8;
	let guest_path = unsafe { CStr::from_ptr(requested_path_ptr) };
	sysunlink.ret = if let Some(host_path) = file_map.get_host_path(guest_path) {
		// We can safely unwrap here, as host_path.as_bytes will never contain internal \0 bytes
		// As host_path_c_string is a valid CString, this implementation is presumed to be safe.
		let host_path_c_string = CString::new(host_path.as_bytes()).unwrap();
		unsafe { libc::unlink(host_path_c_string.as_c_str().as_ptr()) }
	} else {
		error!("The kernel requested to unlink() an unknown path ({guest_path:?}): Rejecting...");
		-ENOENT
	};
}

/// Handles an open syscall by opening a file on the host.
pub fn open(mem: &MmapMemory, sysopen: &mut OpenParams, file_map: &mut UhyveFileMap) {
	let requested_path_ptr = mem.host_address(sysopen.name).unwrap() as *const i8;
	let mut flags = sysopen.flags & ALLOWED_OPEN_FLAGS;
	let guest_path = unsafe { CStr::from_ptr(requested_path_ptr) };
	// See: https://lwn.net/Articles/926782/
	// See: https://github.com/hermit-os/kernel/commit/71bc629
	if (flags & (O_DIRECTORY | O_CREAT)) == (O_DIRECTORY | O_CREAT) {
		error!("An open() call used O_DIRECTORY and O_CREAT at the same time. Aborting...");
		sysopen.ret = -EINVAL;
		return;
	}

	sysopen.ret = if let Some(host_path) = file_map.get_host_path(guest_path) {
		debug!("{guest_path:#?} found in file map.");
		// We can safely unwrap here, as host_path.as_bytes will never contain internal \0 bytes
		// As host_path_c_string is a valid CString, this implementation is presumed to be safe.
		let host_path_c_string = CString::new(host_path.as_bytes()).unwrap();

		let host_fd =
			unsafe { libc::open(host_path_c_string.as_c_str().as_ptr(), flags, sysopen.mode) };
		if let Some(guest_fd) = file_map.fdmap.insert(FdData::Raw(host_fd)) {
			guest_fd.0
		} else if host_fd < 0 {
			host_fd
		} else {
			-ENOENT
		}
	} else {
		debug!("{guest_path:#?} not found in file map.");
		if (flags & O_CREAT) == O_CREAT {
			debug!("Attempting to open a temp file for {guest_path:#?}...");
			// Existing files that already exist should be in the file map, not here.
			// If a supposed attacker can predict where we open a file and its filename,
			// this contigency, together with O_CREAT, will cause the write to fail.
			flags |= O_EXCL;
			#[cfg(target_os = "linux")]
			{
				flags |= file_map.get_io_mode_flags();
			}

			let host_path_c_string = file_map.create_temporary_file(guest_path);
			let new_host_path = host_path_c_string.as_c_str().as_ptr();
			let host_fd = unsafe { libc::open(new_host_path, flags, sysopen.mode) };
			if let Some(guest_fd) = file_map.fdmap.insert(FdData::Raw(host_fd)) {
				guest_fd.0
			} else if host_fd < 0 {
				host_fd
			} else {
				-ENOENT
			}
		} else {
			debug!("Returning -ENOENT for {guest_path:#?}");
			-ENOENT
		}
	}
}

/// Handles an close syscall by closing the file on the host.
pub fn close(sysclose: &mut CloseParams, file_map: &mut UhyveFileMap) {
	sysclose.ret = if file_map
		.fdmap
		.is_fd_present(GuestFd(sysclose.fd.into_raw_fd()))
	{
		match file_map.fdmap.remove(GuestFd(sysclose.fd)) {
			Some(FdData::Raw(fd)) => unsafe { libc::close(fd) },
			// ignore other closures (fdmap's remove already handles stdio)
			_ => 0,
		}
	} else {
		-EBADF
	};
}

/// Handles a v1 read hypercall (for which a guest-provided guest virtual address must be
/// converted to a guest physical address by the host).
pub fn read_v1(
	mem: &MmapMemory,
	sysread: &mut v1::parameters::ReadParams,
	root_pt: GuestPhysAddr,
	file_map: &mut UhyveFileMap,
) {
	if let Ok(guest_phys_addr) = virt_to_phys(sysread.buf, mem, root_pt) {
		let mut tmp = v2::parameters::ReadParams {
			fd: sysread.fd,
			buf: guest_phys_addr,
			len: sysread.len as u64,
			ret: sysread.ret as i64,
		};
		read(mem, &mut tmp, file_map);
		sysread.ret = tmp.ret as isize;
	} else {
		warn!("Unable to convert guest virtual address into guest physical address");
		sysread.ret = -EFAULT as isize;
	}
}

/// Handles a read syscall on the host.
pub fn read(
	mem: &MmapMemory,
	sysread: &mut v2::parameters::ReadParams,
	file_map: &mut UhyveFileMap,
) {
	sysread.ret = if let Some(fdata) = file_map.fdmap.get_mut(GuestFd(sysread.fd.into_raw_fd())) {
		if let Ok(host_address) = mem.host_address(sysread.buf) {
			match fdata {
				FdData::Raw(rfd) => {
					let bytes_read = unsafe {
						libc::read(
							*rfd,
							host_address as *mut libc::c_void,
							sysread.len as usize,
						)
					};
					if bytes_read >= 0 {
						bytes_read as i64
					} else {
						-1
					}
				}
				FdData::Virtual { data, offset } => {
					let data: &[u8] = data.get();
					let remaining = {
						let pos = cmp::min(*offset, data.len() as u64);
						&data[pos as usize..]
					};
					let amt = cmp::min(remaining.len() as u64, sysread.len) as usize;
					assert!(amt <= isize::MAX as usize);

					// SAFETY: the input slices can't overlap, as `host_address` is owned by the guest
					// and `data` is owned by the host.
					unsafe {
						core::ptr::copy_nonoverlapping(
							remaining.as_ptr(),
							host_address as *mut u8,
							amt,
						)
					};
					amt as i64
				}
			}
		} else {
			warn!("Unable to get host address for read buffer");
			-EFAULT as i64
		}
	} else {
		-EBADF as i64
	};
}

/// Handles a v1 write hypercall (for which a guest-provided guest virtual address must be
/// converted to a guest physical address by the host).
pub fn write_v1(
	peripherals: &VmPeripherals,
	syswrite: &v1::parameters::WriteParams,
	root_pt: GuestPhysAddr,
	file_map: &mut UhyveFileMap,
) -> io::Result<()> {
	if let Ok(guest_phys_addr) = virt_to_phys(syswrite.buf, &peripherals.mem, root_pt) {
		let tmp = v2::parameters::WriteParams {
			fd: syswrite.fd,
			buf: guest_phys_addr,
			len: syswrite.len as u64,
		};
		write(peripherals, &tmp, file_map)
	} else {
		warn!("Unable to convert guest virtual address into guest physical address");
		Ok(())
	}
}

/// Handles an write syscall on the host.
pub fn write(
	peripherals: &VmPeripherals,
	syswrite: &v2::parameters::WriteParams,
	file_map: &mut UhyveFileMap,
) -> io::Result<()> {
	let mut bytes_written: usize = 0;
	let gfd = GuestFd(syswrite.fd.into_raw_fd());
	if !file_map.fdmap.is_fd_present(gfd) {
		// We don't write anything if the file descriptor is not available,
		// but this is OK for now, as we have no means of returning an error code
		// and writes are not necessarily guaranteed to write anything.
		return Ok(());
	}

	// Handles to standard outputs differs to that of e.g. files.
	if syswrite.fd == 1 || syswrite.fd == 2 {
		return {
			let bytes = unsafe {
				let guest_phys_addr = syswrite.buf + bytes_written as u64;
				peripherals
					.mem
					.slice_at(guest_phys_addr, syswrite.len as usize)
					.map_err(|e| {
						io::Error::new(
							io::ErrorKind::InvalidInput,
							format!("invalid syswrite buffer: {e:?}"),
						)
					})?
			};
			peripherals.serial.output(bytes)
		};
	}

	while bytes_written != syswrite.len as usize {
		let _guest_phys_addr = syswrite.buf + bytes_written as u64;
		let guest_phys_len = syswrite.len as usize - bytes_written;
		let host_address = peripherals
			.mem
			.host_address(syswrite.buf)
			.map_err(|e| match e {
				MemoryError::BoundsViolation => {
					unreachable!("Bounds violation after host_address function")
				}
				MemoryError::WrongMemoryError => {
					Error::new(ErrorKind::AddrNotAvailable, e.to_string())
				}
			})?;

		match file_map.fdmap.get_mut(gfd).unwrap() {
			FdData::Raw(r) => unsafe {
				let step = libc::write(*r, host_address as *const libc::c_void, guest_phys_len);
				if step >= 0 {
					bytes_written += step as usize;
				} else {
					return Err(io::Error::last_os_error());
				}
			},
			FdData::Virtual { .. } => {
				// virtual fds are read-only
				return Err(io::Error::new(
					io::ErrorKind::ReadOnlyFilesystem,
					format!("Unable to write to virtual file {gfd}"),
				));
			}
		}
	}

	Ok(())
}

/// Handles an lseek syscall on the host.
pub fn lseek(syslseek: &mut LseekParams, file_map: &mut UhyveFileMap) {
	syslseek.offset = match file_map.fdmap.get_mut(GuestFd(syslseek.fd.into_raw_fd())) {
		Some(FdData::Raw(r)) => unsafe {
			libc::lseek(*r, syslseek.offset as i64, syslseek.whence) as isize
		},
		Some(FdData::Virtual { data, offset }) => {
			#[forbid(unused_variables, unreachable_patterns)]
			let tmp = match syslseek.whence {
				SEEK_SET => 0,
				SEEK_CUR => *offset as isize,
				SEEK_END => data.get().len() as isize,
				_ => -1,
			};
			if tmp >= 0 {
				let tmp2 = (tmp as i64) + (syslseek.offset as i64);
				match tmp2.try_into() {
					Ok(tmp3) => {
						*offset = tmp3;
						tmp2 as isize
					}
					_ => -1,
				}
			} else {
				tmp
			}
		}
		None => {
			// TODO: Return -EBADF to the ret field, as soon as it is implemented for LseekParams
			warn!("lseek attempted to use an unknown file descriptor");
			-1
		}
	};
}

/// Copies the arguments of the application into the VM's memory to the destinations specified in `syscmdval`.
pub fn copy_argv(
	path: &OsStr,
	argv: &[String],
	syscmdval: &v1::parameters::CmdvalParams,
	mem: &MmapMemory,
) {
	// copy kernel path as first argument
	let argvp = mem
		.host_address(syscmdval.argv)
		.expect("Systemcall parameters for Cmdval are invalid") as *const GuestPhysAddr;
	let arg_addrs = unsafe { std::slice::from_raw_parts(argvp, argv.len() + 1) };

	{
		let len = path.len();
		// Safety: we drop path_dest before anything else is done with mem
		let path_dest = unsafe {
			mem.slice_at_mut(arg_addrs[0], len + 1)
				.expect("Systemcall parameters for Cmdval are invalid")
		};

		path_dest[0..len].copy_from_slice(path.as_bytes());
		path_dest[len] = 0; // argv strings are zero terminated
	}

	// Copy the application arguments into the vm memory
	for (counter, argument) in argv.iter().enumerate() {
		let len = argument.len();
		let arg_dest = unsafe {
			mem.slice_at_mut(arg_addrs[counter], len + 1)
				.expect("Systemcall parameters for Cmdval are invalid")
		};
		arg_dest[0..len].copy_from_slice(argument.as_bytes());
		arg_dest[len] = 0;
	}
}

/// Copies the environment variables into the VM's memory to the destinations specified in `syscmdval`.
pub fn copy_env(env: &EnvVars, syscmdval: &v1::parameters::CmdvalParams, mem: &MmapMemory) {
	let envp = mem
		.host_address(syscmdval.envp)
		.expect("Systemcall parameters for Cmdval are invalid") as *const GuestPhysAddr;

	let env: Vec<(String, String)> = match env {
		EnvVars::Host => std::env::vars_os()
			.map(|(a, b)| (a.into_string().unwrap(), b.into_string().unwrap()))
			.collect(),
		EnvVars::Set(map) => map
			.iter()
			.map(|(a, b)| (a.to_owned(), b.to_owned()))
			.collect(),
	};
	if env.len() >= MAX_ARGC_ENVC {
		warn!(
			"Environment is larger than the maximum that can be copied to the VM. Remaining environment is ignored"
		);
	}
	let env_addrs = unsafe { std::slice::from_raw_parts(envp, env.len()) };

	// Copy the environment variables into the vm memory
	for (counter, (key, value)) in env.iter().enumerate().take(MAX_ARGC_ENVC) {
		let len = key.len() + value.len() + 1;
		let env_dest = unsafe {
			mem.slice_at_mut(env_addrs[counter], len + 1)
				.expect("Systemcall parameters for Cmdval are invalid")
		};
		//write_env_into_mem(env_dest, key.as_bytes(), value.as_bytes());
		let len = key.len() + value.len() + 1;
		env_dest[0..key.len()].copy_from_slice(key.as_bytes());
		env_dest[key.len()] = b'=';
		env_dest[key.len() + 1..len].copy_from_slice(value.as_bytes());
		env_dest[len] = 0;
	}
}
